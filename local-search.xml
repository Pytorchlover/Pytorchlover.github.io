<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>My study situation</title>
    <link href="/2023/01/23/My-study-situation/"/>
    <url>/2023/01/23/My-study-situation/</url>
    
    <content type="html"><![CDATA[<h1>参加百度飞桨的线上峰会</h1><p>时间：11月30日<br>参加了百度飞桨的线上峰会，对人工智能行业的发展有了一个全新的认知，结识了很多其它学校优秀的学长学姐。认识了一大批热爱人工智能的大佬。</p><p>活动纪念照片：<br><img src="https://img-blog.csdnimg.cn/4c43deff7cb04ab591fd184cd7acc9d2.jpeg" alt="在这里插入图片描述"></p><h1>参加了百度飞桨的AI达人特训营</h1><p>时间：11月28日——12月10日<br>内容：学习了如何在AI Studio平台使用Paddle框架进行项目的建立和实施运行，并最终完成了精品项目的创建，取得了结营证书和结营礼品。并在此期间认识到了大连理工大学的百度飞桨领航团团长，在此期间担任我的导师，对我的帮助很大。并且也认识到了更多优秀的人，可以一起探讨相关知识。<br>成果：<br><img src="https://img-blog.csdnimg.cn/bb3aaab2bc7b492ea68cc8bd9cfad9e3.jpeg" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/53f6676dbc514bc992ad197feb3dfcdf.png" alt="在这里插入图片描述"><br>项目链接：<a href="https://aistudio.baidu.com/aistudio/projectdetail/5149667">https://aistudio.baidu.com/aistudio/projectdetail/5149667</a></p><h1>比赛</h1><p>时间：12月11日<br>由于参加的国际青年人工智能大赛的ROS巡航组省赛拿了一等奖，所以我们晋级到了国赛，但是这个时候我的队友都已经走完了，同时因为疫情，国赛也是在线上举行，于是我叫上我还没有回家的室友，跟我一起去汇森楼完成了场地的搭建和比赛视频拍摄的任务。在此期间虽然非常的累，不过所有的付出都是有汇报的，我们很幸运地取得了国赛二等奖的好成绩。但是我却也因此而阳了~<br><img src="https://img-blog.csdnimg.cn/5bfa444e9fc747c9b495bd962198eebb.jpeg" alt="在这里插入图片描述"></p><h1>参加了百度飞桨全栈AI能力提升计划-第三期</h1><p>时间：12月份到1月16日<br>内容：回家之后，因为得了新冠，所以在床上躺了将近快两周的时间，这段时间基本煤怎么学习。后来转阴了后，我从地下室搬到了我的卧室，感觉到最近什么都没学，一阵空虚，所以我就在网上找到了百度飞桨的免费课程，刚好遇上了他们的学习打卡活动，并在最后拿到了学习打卡个人成绩第二名，队伍成绩第二名的成绩，而且还拿到了活动的结课证书和第二名奖品——京东的按摩仪，第一名是北邮的，实在卷不过，他拿到了700多的机械键盘，说实话有点遗憾~<br><img src="https://img-blog.csdnimg.cn/4ef87abd86e04d08ba1db852d46b6da1.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/ec9dddb3b5e24a828abfd270369f7f7d.png" alt="在这里插入图片描述"></p><h1>每日读书学习和记笔记</h1><p>时间：从12月中旬持续到今天及以后<br>在学习了深度学习这个方向以后，我总感觉自己的基础还是很薄弱，有些细节部分理解的还不够透彻，于是我就从网上买了《深度学习花书》和《带你动手学深度学习》这两本书，一遍打基础，一遍进行实战。并定期将自己的一些笔记发表到CSDN博客上，期间也收获了不少的阅读量和粉丝。<br>博客地址：<a href="https://blog.csdn.net/m0_63007797?type=lately">https://blog.csdn.net/m0_63007797?type=lately</a><br><img src="https://img-blog.csdnimg.cn/eba25914b67540ceb3a0ee53db83714b.png" alt="在这里插入图片描述"></p><h1>每日英语刷题</h1><p>时间：12月中旬到前段时间<br>说实话，好久没刷英语四级了，直到现在我还对四级没有底气，由于长时间不刷题，所以我的英语阅读理解水平下降了很多，第一次刷的时候，完型填空的题只对了一个，好在我刷了一段时间后，正确率提升上去了，但是作文和翻译以及听力 我感觉还是搞不太定。<br>目前已经刷了7-8套大概，这两天由于过年也没有刷题。<br><img src="https://img-blog.csdnimg.cn/2ef69198fe2e45619cae6c45c397bcad.jpeg" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/8428d91027aa471fa8ccf965c5ca54b2.jpeg" alt="在这里插入图片描述"><br>这错题量也真是吓人，说实话，做到现在，最好的成绩也就是错一个，没有全对过。有时候文章主题理解错了，基本就是全军覆没~</p><h1>搭建个人博客</h1><p>时间：前几天，大概记不清楚了，搭建只用了一天的时间，但是部署花了好几天，因为当初好多网站都还没实名认证，可能是过年的原因，一直没人审核<br>内容：我在看了别人搭建的个人博客后，说实话心里一直痒痒的，也一直想自己搭建一个属于自己的个人博客，但是苦于我前端只学了html、css和java，好多框架都还没有学，所以自己一手搭建不太可能，所以我问了豪哥，说可以用框架搭建，于是我便从众多框架中选中了一款国外的框架hexo。并搭建了自己的博客完成了部署。<br><img src="https://img-blog.csdnimg.cn/bd57e221ca6e459fba2af03f9d99bcbf.png" alt="在这里插入图片描述"><br>博客地址：<a href="https://pytorchlover.github.io/">https://pytorchlover.github.io/</a></p><h1>总结</h1><p>时间真的过得很快，一转眼，一个多月过去了，眼看马上都要开学了，在快开学之际，又兴奋也有害怕，兴奋的是这一个假期我终于做到了每日学习时间稳定在10小时之间以及开学就可以见到一些熟悉的人和事，害怕的就是开学就要考试，头疼，而且还有四级，四级真的没把握~~如果能把豪哥的脑子借我用一天多好😜</p>]]></content>
    
    
    <categories>
      
      <category>学习总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Learning summary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python机器学习数据建模与分析——Numpy和Pandas综合应用案例：空气质量监测数据的预处理和基本分析</title>
    <link href="/2023/01/21/text1/"/>
    <url>/2023/01/21/text1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章主要以北京市空气质量监测数据为例子，聚集数据建模中的数据预处理和基本分析环节，说明Numpy和Pandas的数据读取、数据分组、数据重编码、分类汇总等数据加工处理功能。同时在实现案例的过程中对用到的Numpy和Pandas相关函数进行讲解。</p></blockquote><h1>数据</h1><p>在进行案例之前，我首先将本案例即将用到的数据集链接分享：<a href="https://kdocs.cn/l/crZwpOnTuY9T">北京市空气质量数据</a><br>大家可以进入文档中，将数据复制到你自己创建的Excel文件中，更改文件名为北京市空气质量数据。<br><img src="https://img-blog.csdnimg.cn/b3c9e4f8d20b46c7a1e5683093b6181f.png" alt="在这里插入图片描述"></p><p>数据含义解释：</p><table><thead><tr><th>数据名称</th><th>含义</th></tr></thead><tbody><tr><td>日期</td><td>空气质量监测的日期</td></tr><tr><td>AQI</td><td>空气质量指数</td></tr><tr><td>质量等级</td><td>空气质量等级，判段污染程度</td></tr><tr><td>PM2.5</td><td>空气中细颗粒物的含量</td></tr><tr><td>PM10</td><td>空气中人体可吸入颗粒物的含量</td></tr><tr><td>SO2</td><td>空气中二氧化硫的含量</td></tr><tr><td>CO</td><td>空气中一氧化碳的含量</td></tr><tr><td>NO2</td><td>空气中二氧化氮的含量</td></tr><tr><td>03</td><td>空气中臭氧的含量</td></tr></tbody></table><h1>一、空气质量监测数据的预处理</h1><p>数据预处理的目标如下：</p><ul><li>根据空气质量监测的日期，生成对应的季度标志变量。</li><li>对空气质量指数AQI分组，获得对应的空气质量等级。<br>代码及运行结果如下所示：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br><br>data=pd.read_excel(<span class="hljs-string">&#x27;北京市空气质量数据.xlsx&#x27;</span>)  <span class="hljs-comment"># 数据文件地址</span><br>data=data.replace(<span class="hljs-number">0</span>,np.NaN)<br>data[<span class="hljs-string">&#x27;年&#x27;</span>]=data[<span class="hljs-string">&#x27;日期&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x:x.year)<br>month=data[<span class="hljs-string">&#x27;日期&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x:x.month)<br>quarter_month=&#123;<span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;一季度&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>:<span class="hljs-string">&#x27;一季度&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>:<span class="hljs-string">&#x27;一季度&#x27;</span>,<br>               <span class="hljs-string">&#x27;4&#x27;</span>:<span class="hljs-string">&#x27;二季度&#x27;</span>,<span class="hljs-string">&#x27;5&#x27;</span>:<span class="hljs-string">&#x27;二季度&#x27;</span>,<span class="hljs-string">&#x27;6&#x27;</span>:<span class="hljs-string">&#x27;二季度&#x27;</span>,<br>               <span class="hljs-string">&#x27;7&#x27;</span>:<span class="hljs-string">&#x27;三季度&#x27;</span>,<span class="hljs-string">&#x27;8&#x27;</span>:<span class="hljs-string">&#x27;三季度&#x27;</span>,<span class="hljs-string">&#x27;9&#x27;</span>:<span class="hljs-string">&#x27;三季度&#x27;</span>,<br>              <span class="hljs-string">&#x27;10&#x27;</span>:<span class="hljs-string">&#x27;四季度&#x27;</span>,<span class="hljs-string">&#x27;11&#x27;</span>:<span class="hljs-string">&#x27;四季度&#x27;</span>,<span class="hljs-string">&#x27;12&#x27;</span>:<span class="hljs-string">&#x27;四季度&#x27;</span>&#125;<br>data[<span class="hljs-string">&#x27;季度&#x27;</span>]=month.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x:quarter_month[<span class="hljs-built_in">str</span>(x)])<br>bins=[<span class="hljs-number">0</span>,<span class="hljs-number">50</span>,<span class="hljs-number">100</span>,<span class="hljs-number">150</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span>,<span class="hljs-number">1000</span>]<br>data[<span class="hljs-string">&#x27;等级&#x27;</span>]=pd.cut(data[<span class="hljs-string">&#x27;AQI&#x27;</span>],bins,labels=[<span class="hljs-string">&#x27;一级优&#x27;</span>,<span class="hljs-string">&#x27;二级良&#x27;</span>,<span class="hljs-string">&#x27;三级轻度污染&#x27;</span>,<span class="hljs-string">&#x27;四级中度污染&#x27;</span>,<span class="hljs-string">&#x27;五级重度污染&#x27;</span>,<span class="hljs-string">&#x27;六级严重污染&#x27;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;对AQI的分组结果：\n&#123;0&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(data[[<span class="hljs-string">&#x27;日期&#x27;</span>,<span class="hljs-string">&#x27;AQI&#x27;</span>,<span class="hljs-string">&#x27;等级&#x27;</span>,<span class="hljs-string">&#x27;季度&#x27;</span>]]))<br><br><span class="hljs-comment"># 运行结果如下：</span><br>对AQI的分组结果：<br>             日期    AQI      等级   季度<br><span class="hljs-number">0</span>    <span class="hljs-number">2014</span>-01-01   <span class="hljs-number">81.0</span>     二级良  一季度<br><span class="hljs-number">1</span>    <span class="hljs-number">2014</span>-01-02  <span class="hljs-number">145.0</span>  三级轻度污染  一季度<br><span class="hljs-number">2</span>    <span class="hljs-number">2014</span>-01-03   <span class="hljs-number">74.0</span>     二级良  一季度<br><span class="hljs-number">3</span>    <span class="hljs-number">2014</span>-01-04  <span class="hljs-number">149.0</span>  三级轻度污染  一季度<br><span class="hljs-number">4</span>    <span class="hljs-number">2014</span>-01-05  <span class="hljs-number">119.0</span>  三级轻度污染  一季度<br><span class="hljs-meta">... </span>        ...    ...     ...  ...<br><span class="hljs-number">2150</span> <span class="hljs-number">2019</span>-<span class="hljs-number">11</span>-<span class="hljs-number">22</span>  <span class="hljs-number">183.0</span>  四级中度污染  四季度<br><span class="hljs-number">2151</span> <span class="hljs-number">2019</span>-<span class="hljs-number">11</span>-<span class="hljs-number">23</span>  <span class="hljs-number">175.0</span>  四级中度污染  四季度<br><span class="hljs-number">2152</span> <span class="hljs-number">2019</span>-<span class="hljs-number">11</span>-<span class="hljs-number">24</span>   <span class="hljs-number">30.0</span>     一级优  四季度<br><span class="hljs-number">2153</span> <span class="hljs-number">2019</span>-<span class="hljs-number">11</span>-<span class="hljs-number">25</span>   <span class="hljs-number">40.0</span>     一级优  四季度<br><span class="hljs-number">2154</span> <span class="hljs-number">2019</span>-<span class="hljs-number">11</span>-<span class="hljs-number">26</span>   <span class="hljs-number">73.0</span>     二级良  四季度<br><br>[<span class="hljs-number">2155</span> rows x <span class="hljs-number">4</span> columns]<br></code></pre></td></tr></table></figure><p><strong>代码说明：</strong><br>（1）第6行：利用数据框函数replace()将数据框中的0（表示无监测结果）替换为缺失值NaN。<br>（2）第7，8行：利用.apply()方法以及匿名函数，基于“日期”变量得到每个样本观测的年份和月份。<br>（3）第9-12行：建立一个关于月份和季度的字典quarter_month。<br>（4）第13行：利用Python函数map()，依据字典quarter_month，将序列month中的1，2，3等月份映射（对应）到相应的季度上。<br>（5）第14行：生成一个后续用于对AQI分组的列表bins。它描述了AQI和空气质量等级的数值对应关系。<br>（6）第15行：利用Pandas的cut()方法对AQI进行分组。</p><h2 id="二、上例中所用到的函数讲解">二、上例中所用到的函数讲解</h2><h3 id="2-1-lambda表达式">2.1 lambda表达式</h3><p><strong>介绍：</strong><br>Lambda 表达式是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包。<br><img src="https://img-blog.csdnimg.cn/9eb2ed18e93541eaa26323fcc5232fd7.png#pic_center" alt="在这里插入图片描述"><br><strong>示例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">double1 = <span class="hljs-keyword">lambda</span> x:<span class="hljs-number">2</span>*x<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;lambda表达式的输出：&quot;</span>,double1(<span class="hljs-number">2</span>))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">double2</span>(<span class="hljs-params">x</span>):<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*x<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;double2函数的输出&quot;</span>,double2(<span class="hljs-number">2</span>))<br><span class="hljs-comment"># 输出结果如下：</span><br><span class="hljs-keyword">lambda</span>表达式的输出： <span class="hljs-number">4</span><br>double2函数的输出 <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>详细可参考博客:<a href="http://t.csdn.cn/gMS4p">python的lambda表达式详细讲解</a></p><h3 id="2-2-apply-函数">2.2 apply()函数</h3><p><strong>介绍：</strong><br><strong>apply</strong>函数是<strong>pandas</strong>里面所有函数中自由度最高的函数。该函数如下：</p><blockquote><p>*DataFrame.apply(func, axis=0, broadcast=False, raw=False, reduce=None,args=(), *<em>kwds)</em></p></blockquote><p>该函数最有用的是第一个参数，这个参数是函数，相当于C/C++的函数指针。<br>这个函数需要自己实现，函数的传入参数根据axis来定，比如axis = 1，就会把一行数据作为Series的数据 结构传入给自己实现的函数中，我们在函数中实现对Series不同属性之间的计算，返回一个结果，则apply函数 会自动遍历每一行DataFrame的数据，最后将所有结果组合成一个Series数据结构并返回。<br><strong>说太多概念性的东西可能不太理解，这里直接上样例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br><br>data=pd.read_excel(<span class="hljs-string">&#x27;E:\python机器学习数据建模与分析\数据\北京市空气质量数据.xlsx&#x27;</span>)<br><span class="hljs-built_in">print</span>(data[<span class="hljs-string">&#x27;日期&#x27;</span>])<br>data[<span class="hljs-string">&#x27;年&#x27;</span>]=data[<span class="hljs-string">&#x27;日期&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x:x.year)<br><span class="hljs-built_in">print</span>(data[<span class="hljs-string">&#x27;年&#x27;</span>])<br><br><span class="hljs-comment"># 输出结果如下：</span><br><span class="hljs-number">0</span>      <span class="hljs-number">2014</span>-01-01<br><span class="hljs-number">1</span>      <span class="hljs-number">2014</span>-01-02<br><span class="hljs-number">2</span>      <span class="hljs-number">2014</span>-01-03<br><span class="hljs-number">3</span>      <span class="hljs-number">2014</span>-01-04<br><span class="hljs-number">4</span>      <span class="hljs-number">2014</span>-01-05<br>          ...    <br><span class="hljs-number">2150</span>   <span class="hljs-number">2019</span>-<span class="hljs-number">11</span>-<span class="hljs-number">22</span><br><span class="hljs-number">2151</span>   <span class="hljs-number">2019</span>-<span class="hljs-number">11</span>-<span class="hljs-number">23</span><br><span class="hljs-number">2152</span>   <span class="hljs-number">2019</span>-<span class="hljs-number">11</span>-<span class="hljs-number">24</span><br><span class="hljs-number">2153</span>   <span class="hljs-number">2019</span>-<span class="hljs-number">11</span>-<span class="hljs-number">25</span><br><span class="hljs-number">2154</span>   <span class="hljs-number">2019</span>-<span class="hljs-number">11</span>-<span class="hljs-number">26</span><br>Name: 日期, Length: <span class="hljs-number">2155</span>, dtype: datetime64[ns]<br><span class="hljs-number">0</span>       <span class="hljs-number">2014</span><br><span class="hljs-number">1</span>       <span class="hljs-number">2014</span><br><span class="hljs-number">2</span>       <span class="hljs-number">2014</span><br><span class="hljs-number">3</span>       <span class="hljs-number">2014</span><br><span class="hljs-number">4</span>       <span class="hljs-number">2014</span><br>        ... <br><span class="hljs-number">2150</span>    <span class="hljs-number">2019</span><br><span class="hljs-number">2151</span>    <span class="hljs-number">2019</span><br><span class="hljs-number">2152</span>    <span class="hljs-number">2019</span><br><span class="hljs-number">2153</span>    <span class="hljs-number">2019</span><br><span class="hljs-number">2154</span>    <span class="hljs-number">2019</span><br>Name: 年, Length: <span class="hljs-number">2155</span>, dtype: int64<br><br></code></pre></td></tr></table></figure><p>通过输出结果我们其实可以看出，我们使用apply函数可以将日期中的年份提取出来。<br>想要更加详细了解可以看这篇博客：<a href="http://t.csdn.cn/HmwaQ">python中apply函数</a></p><h3 id="2-3-map函数">2.3 map函数</h3><p><strong>介绍：</strong><br>map函数是 Python 内置的高阶函数，在Python3.0版本中，它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，返回一个list的<strong>可迭代对象</strong>。如果想得到一个list列表，则用list（map()）进行强制转换。</p><blockquote><p><em>map(function, iterable)</em></p></blockquote><ul><li>function – 函数</li><li>iterable – 序列</li></ul><p>map函数的第一个参数是一个函数，第二个参数是一个序列，里面的每个元素作为函数的参数进行计算和判断。函数返回值则被作为新的元素存储起来。</p><p><strong>示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x**<span class="hljs-number">2</span><span class="hljs-comment">#计算x的平方</span><br><br>lists = <span class="hljs-built_in">range</span>(<span class="hljs-number">11</span>)       <span class="hljs-comment">#创建包含 0-10 的列表</span><br>a = <span class="hljs-built_in">map</span>(add,lists)      <span class="hljs-comment">#计算 0-10 的平方，并映射</span><br><span class="hljs-built_in">print</span>(a)                <span class="hljs-comment"># 返回一个迭代器：&lt;map object at 0x0000025574F68F70&gt;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(a))          <span class="hljs-comment"># 使用 list() 转换为列表。</span><br><span class="hljs-comment"># 结果为：[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br><br><br><span class="hljs-comment"># 使用lambda匿名函数的形式复现上面的代码会更简洁一些</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x:x**<span class="hljs-number">2</span>,<span class="hljs-built_in">range</span>(<span class="hljs-number">11</span>))))   <br><span class="hljs-comment"># 结果为：[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></code></pre></td></tr></table></figure><h3 id="2-4-cut函数">2.4 cut函数</h3><p>在对数据进行分段分组时，可采用cut方法，用bins的方式实现。这种情况一般使用于，对于年龄、分数等数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> pandas <span class="hljs-keyword">import</span> Series,DataFrame<br><span class="hljs-comment">#用随机数产生一个二维数组。分别是年龄的性别。</span><br>df=pd.DataFrame(&#123;<span class="hljs-string">&#x27;Age&#x27;</span>:np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">70</span>,<span class="hljs-number">100</span>),<br>                <span class="hljs-string">&#x27;Sex&#x27;</span>:np.random.choice([<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>],<span class="hljs-number">100</span>),<br>                &#125;)<br><span class="hljs-comment">#用cut函数对于年龄进行分段分组，用bins来对年龄进行分段，左开右闭</span><br>age_groups=pd.cut(df[<span class="hljs-string">&#x27;Age&#x27;</span>],bins=[<span class="hljs-number">0</span>,<span class="hljs-number">18</span>,<span class="hljs-number">35</span>,<span class="hljs-number">55</span>,<span class="hljs-number">70</span>,<span class="hljs-number">100</span>])<br><span class="hljs-comment"># print(age_groups)</span><br><span class="hljs-built_in">print</span>(df.groupby(age_groups).count())<br><br><span class="hljs-comment"># 结果如下所示：</span><br>           Age  Sex<br>Age                <br>(<span class="hljs-number">0</span>, <span class="hljs-number">18</span>]     <span class="hljs-number">23</span>   <span class="hljs-number">23</span><br>(<span class="hljs-number">18</span>, <span class="hljs-number">35</span>]    <span class="hljs-number">23</span>   <span class="hljs-number">23</span><br>(<span class="hljs-number">35</span>, <span class="hljs-number">55</span>]    <span class="hljs-number">31</span>   <span class="hljs-number">31</span><br>(<span class="hljs-number">55</span>, <span class="hljs-number">70</span>]    <span class="hljs-number">20</span>   <span class="hljs-number">20</span><br>(<span class="hljs-number">70</span>, <span class="hljs-number">100</span>]    <span class="hljs-number">0</span>    <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>cut()方法主要用于对<font color="ff0000">连续数据分组</font>，也称对连续数据进行离散化处理。在上面的例子中，我们使用cut()，依照分组标准（即列表bins）对变量AQI进行分组并给出分组标签。即：AQI在区间$(0, 50]$的为一组，组标签为“一级优”，在区间$(50,100]$的为一组，组标签为“二级良”，等等以此类推。<font color="ff0000">生成的“等级”与变量（与数据集中原有的“质量等级”一致）为分类型（有顺序的）变量。</font></p><h3 id="补充解释DataFrame函数：">补充解释DataFrame函数：</h3><p>DataFrame是一个类似于<font color="#dd0000">二维数组</font>或<font color="#dd0000">表格（如excel）</font>的对象，它每列的数据都可以是不同的数据类型。</p><p><strong>注意：</strong><br>DataFrame的索引不仅有行索引，还有列索引，数据可以有多列<br><img src="https://img-blog.csdnimg.cn/6bc3d36085064764ad98c42206e555e7.png#pic_center" alt="在这里插入图片描述"></p><p><strong>创建方式：</strong><br>Pandas的DataFrame类对象的原型如下（仅作了解）：</p><blockquote><p><em>pandas.DataFrame（data = None,index = None,columns = None,dtype = None,copy = False ）</em></p></blockquote><p>index：表示行标签。若不设置该参数，则默认会自动创建一个从0~N的整数索引。<br>columns：列标签<br><strong>举个例子：</strong><br>通过传入数组来创建DataFrame类对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br><span class="hljs-comment"># 创建数组</span><br>demo_arr = np.array([[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>],<br>                     [<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>]])<br><span class="hljs-comment"># 基于数组创建DataFrame对象</span><br>df_obj = pd.DataFrame(demo_arr)<br><span class="hljs-built_in">print</span>(df_obj)<br><br><span class="hljs-comment"># 输出结果如下：</span><br>   <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span><br><span class="hljs-number">0</span>  a  b  c<br><span class="hljs-number">1</span>  d  e  f<br><br></code></pre></td></tr></table></figure><p>在创建DataFrame类对象时，如果为其指定了<font color="0000ddd">列索引</font>，则DataFrame的列会按照指定索引的顺序进行排列，比如指定列索引No1,No2, No3的顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br><span class="hljs-comment"># 创建数组</span><br>demo_arr = np.array([[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>],<br>                     [<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>]])<br><span class="hljs-comment"># 基于数组创建DataFrame对象</span><br>df_obj = pd.DataFrame(demo_arr, columns=[<span class="hljs-string">&#x27;No1&#x27;</span>, <span class="hljs-string">&#x27;No2&#x27;</span>, <span class="hljs-string">&#x27;No3&#x27;</span>])<br><span class="hljs-built_in">print</span>(df_obj)<br><br><span class="hljs-comment"># 输出结果如下：</span><br>  No1 No2 No3<br><span class="hljs-number">0</span>   a   b   c<br><span class="hljs-number">1</span>   d   e   f<br></code></pre></td></tr></table></figure><p>详细了解请看博客：<a href="https://edu.csdn.net/skill/python02/python-3-204?category=883&amp;typeId=17520#2_Series_14">Pandas数据结构–Series、DataFrame详解</a></p><h1>三、空气质量监测数据的基本分析</h1><p>在上面的基础上，我们利用Pandas的数据分类汇总和列联表编制等功能，对空气监测数据进行基本分析。基本分析的目标如下：</p><ul><li>计算各季度AQI和PM2.5的平均值等描述统计量。</li><li>找到空气质量较差的若干天的数据，以及各季度中空气质量较差的若干天的数据。</li><li>计算季度和空气质量等级的交叉列联表。</li><li>派生空气质量等级的虚拟变量。</li><li>数据集的抽样。</li></ul><h3 id="3-1-基本统计描述">3.1 基本统计描述</h3><p><strong>以下代码利用Pandas实现以上前三个目标：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;各季度AQI和PM2.5的均值:\n&#123;0&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(data.loc[:,[<span class="hljs-string">&#x27;AQI&#x27;</span>,<span class="hljs-string">&#x27;PM2.5&#x27;</span>]].groupby(data[<span class="hljs-string">&#x27;季度&#x27;</span>]).mean()))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;各季度AQI和PM2.5的描述统计量:\n&#x27;</span>,data.groupby(data[<span class="hljs-string">&#x27;季度&#x27;</span>])[<span class="hljs-string">&#x27;AQI&#x27;</span>,<span class="hljs-string">&#x27;PM2.5&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x:x.describe()))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">top</span>(<span class="hljs-params">df,n=<span class="hljs-number">10</span>,column=<span class="hljs-string">&#x27;AQI&#x27;</span></span>):<br>    <span class="hljs-keyword">return</span> df.sort_values(by=column,ascending=<span class="hljs-literal">False</span>)[:n] <span class="hljs-comment"># 对AQI列的数据进行降序排列，然后返回前n个（这里n=10）</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;空气质量最差的5天:\n&#x27;</span>,top(data,n=<span class="hljs-number">5</span>)[[<span class="hljs-string">&#x27;日期&#x27;</span>,<span class="hljs-string">&#x27;AQI&#x27;</span>,<span class="hljs-string">&#x27;PM2.5&#x27;</span>,<span class="hljs-string">&#x27;等级&#x27;</span>]])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;各季度空气质量最差的3天:\n&#x27;</span>,data.groupby(data[<span class="hljs-string">&#x27;季度&#x27;</span>]).apply(<span class="hljs-keyword">lambda</span> x:top(x,n=<span class="hljs-number">3</span>)[[<span class="hljs-string">&#x27;日期&#x27;</span>,<span class="hljs-string">&#x27;AQI&#x27;</span>,<span class="hljs-string">&#x27;PM2.5&#x27;</span>,<span class="hljs-string">&#x27;等级&#x27;</span>]]))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;各季度空气质量情况:\n&#x27;</span>,pd.crosstab(data[<span class="hljs-string">&#x27;等级&#x27;</span>],data[<span class="hljs-string">&#x27;季度&#x27;</span>],margins=<span class="hljs-literal">True</span>,margins_name=<span class="hljs-string">&#x27;总计&#x27;</span>,normalize=<span class="hljs-literal">False</span>))<br><br></code></pre></td></tr></table></figure><p>输出结果如下图所示：<br><img src="https://img-blog.csdnimg.cn/6e2423fe8fa6436ab6d66de1c34e187a.png" alt="在这里插入图片描述"><br><strong>代码说明：</strong><br>（1）第1行：利用数据框的groupby()方法，计算各季度AQI和PM2.5的平均值。<font color="000ff">groupby()方法是将数据按指定变量进行分组，可以对分组结果进一步计算均值等。</font><br>（2）第2行：计算几个季度AQI和PM2.5的基本描述统计量（均值，标准差，最小值，四分位数，最大值）。<font color="000ff">这里将groupby、apply以及lambda表达式集中在一起使用。首先，将数据按照季度分组；然后，对分组后的AQI和PM2.5，分别根据lambda表达式指定的处理步骤处理（计算基本描述统计量）。</font><br>（3）第4，5行：定义了一个名为top的用户自定义函数：对给定数据框，按指定列（默认AQI列）值的降序排序，返回排在前n（默认10）条数据。<br>（4）第6行：调用用户自定义函数top，对data数据框中，按AQI值的降序排序并返回前5条数据，即AQI最高的5天的数据。<br>（5）第7行：首先对数据按季度分组，依次对分组数据调用用户自定义函数top，得到各季度AQI最高的3天数据。<br>（6）第8行：利用Pandas函数crosstab()对数据按季度和空气质量等级交叉分组，并给出各个组的样本量。<br> 例如，在2014年1月至2019年11月之间的2149天中，空气质量为严重污的天数为46天，集中分布在第一和第四季的冬天供暖季，分别是21天和23天。<br> crosstab()函数可以方便地编制两个分类变量的列联表。列联表单元格可以是频数，也可以是百分比，还可指定是否添加行列合计等。</p><h3 id="3-2-groupby函数">3.2 groupby函数</h3><p><img src="https://img-blog.csdnimg.cn/f153bcf67f8a4a73b0507cfe460eacfb.png" alt="在这里插入图片描述"><br>pandas对象支持的groupby()方法语法格式如下：</p><blockquote><p><em>groupby(by=None, axis=0, level=None, as_index=True, sort=True, group_keys=True, squeeze=False)</em></p></blockquote><ul><li>参数by用于指定分组依据，可以是函数、字典、Series对象、DataFrame对象的列名等；</li><li>参数axis表示分组轴的方向，可以是0或’index’，1或’columns’，默认值为0；</li><li>参数level表示如果某个轴是一个MultiIndex对象（层级索引），则按照特定级别或多个级别分组；</li><li>参数as_index=False表示用来分组的列中的数据不作为结果DataFrame对象的index；</li><li>参数sort指定是否对分组标签进行排序，默认值为True。</li></ul><p><strong>使用groupby()方法可以实现两种分组方式，返回的对象结果不同。如果仅对DataFrame对象中的数据进行分组，将返回一个DataFrameGroupBy对象；如果是对DataFrame对象中某一列数据进行分组，将返回一个SeriesGroupBy对象。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 按列名对列分组</span><br>obj1 = data[<span class="hljs-string">&#x27;Country&#x27;</span>].groupby(data[<span class="hljs-string">&#x27;Region&#x27;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(obj1))<br><br><span class="hljs-comment"># out</span><br>&lt;<span class="hljs-keyword">class</span><span class="hljs-string">&#x27;pandas.core.groupby.generic.SeriesGroupBy’&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string"># 按列名对数据分组</span><br><span class="hljs-string">obj2 = data.groupby(data[&#x27;</span>Region<span class="hljs-string">&#x27;])</span><br><span class="hljs-string">print(type(obj2))</span><br><span class="hljs-string"># out</span><br><span class="hljs-string">&lt;class&#x27;</span>pandas.core.groupby.generic.DataFrameGroupBy<span class="hljs-string">&#x27;&gt;</span><br></code></pre></td></tr></table></figure><p>可以使用groupby(‘label’)方法按照单列分组，也可以使用groupby(‘label1’,‘label2’)方法按照多列分组，返回一个GroupBy对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">data.groupby(<span class="hljs-string">&#x27;Region&#x27;</span>)<span class="hljs-comment"># 按单列分组</span><br><span class="hljs-comment"># out：&lt;pandas.core.groupby.generic.DataFrameGroupByobject at 0x7f0aee73e850&gt;</span><br>data.groupby([<span class="hljs-string">&#x27;Region&#x27;</span>, <span class="hljs-string">&#x27;Country&#x27;</span>])<span class="hljs-comment"># 按多列分组</span><br><span class="hljs-comment"># out：&lt;pandas.core.groupby.generic.DataFrameGroupByobject at 0x7f0aedeb99d0&gt;</span><br></code></pre></td></tr></table></figure><p><font color="fff0000">使用数据分组的groupby()方法返回一个GroupBy对象，此时并未真正进行计算，只是保存了数据分组的中间结果。</font></p><h3 id="3-3-派生虚拟自变量">3.3 派生虚拟自变量</h3><p>这里，利用Pandas派生空气质量等级的虚拟变量。<br><font color="000fff">虚拟变量也称作哑变量，是统计学处理分类型数据的一种常用方式。对具有K个类别的分类型变量X，也可以生成K个变量如$X_1,X_2,…,X_K$,且每个变量仅有0和1两种取值。这些变量称为分类型变量的虚拟变量。其中，1表示属于某个类别，0表示不属于某个类别，和True和False含义差不多。</font></p><p>虚拟变量在数据预测建模中将起到非常重要的作用。Pandas生成虚拟变量的实现如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.get_dummies(data[<span class="hljs-string">&#x27;等级&#x27;</span>])<br>data.join(pd.get_dummies(data[<span class="hljs-string">&#x27;等级&#x27;</span>]))<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/e4d8d1946ac94be5946a004fc0740cfd.png" alt="在这里插入图片描述"><br><strong>代码说明：</strong><br>（1）第1行：利用Pandas的get_dummies得到分类型变量“等级”的哑变量。<br> 例如：数据中的“等级”是包含6个类别的分类型变量。相应的6个虚拟变量依次表示：是否为一级优，是否为二级良等等。如2014年1月1日的等级为二级良，所以后面二级良的哑变量为1，其它的相应为0。<br>（2）第2行：利用数据框的join()方法，将原始数据和哑变量数据，按行索引进行横向合并。<br> 使用join()方法进行数据的横向合并的时候，要确保两分数据的样本观测在行索引上是一一对应的，否则会出现“张冠李戴”，也就是哑变量的取值和实际不符。</p><h3 id="3-4-数据集的抽样">3.4 数据集的抽样</h3><p>数据集的抽样在数据建模中极其普遍，因此掌握Numpy的抽样实现方式是非常必要的。以下利用Numpy对空气质量监测数据进行了两种策略的抽样：一种是简单随机抽样；另一种是依条件抽样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 简单随机抽样</span><br>np.random.seed(<span class="hljs-number">123</span>)<br>sampler=np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(data),<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(sampler)<br>sampler=np.random.permutation(<span class="hljs-built_in">len</span>(data))[:<span class="hljs-number">10</span>]<br><span class="hljs-built_in">print</span>(sampler)<br><span class="hljs-comment"># 条件抽样</span><br>data.take(sampler)<br>data.loc[data[<span class="hljs-string">&#x27;质量等级&#x27;</span>]==<span class="hljs-string">&#x27;优&#x27;</span>,:]<br></code></pre></td></tr></table></figure><p>简单随机抽样的结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-number">1346</span> <span class="hljs-number">1122</span> <span class="hljs-number">1766</span> <span class="hljs-number">2154</span> <span class="hljs-number">1147</span> <span class="hljs-number">1593</span> <span class="hljs-number">1761</span>   <span class="hljs-number">96</span>   <span class="hljs-number">47</span>   <span class="hljs-number">73</span>]<br>[<span class="hljs-number">1883</span>  <span class="hljs-number">326</span>   <span class="hljs-number">43</span> <span class="hljs-number">1627</span> <span class="hljs-number">1750</span> <span class="hljs-number">1440</span>  <span class="hljs-number">993</span> <span class="hljs-number">1469</span> <span class="hljs-number">1892</span>  <span class="hljs-number">865</span>]<br></code></pre></td></tr></table></figure><p>条件抽样的结果如下：<br><img src="https://img-blog.csdnimg.cn/0f51d764900340f2a11f339581b26919.png" alt="在这里插入图片描述"><br><strong>代码说明：</strong><br>（1）第3行：利用Pandas函数random.randint()在指定范围内随机抽取指定个数（这里是10）的随机数。<br>（2）第 5行：利用Pandas函数random.permutation是对数据随机打乱重排。之后再抽取前10个样本观测。<br>（3）第8行：利用数据框的take()方法，基于指定随机数获得数据集的一个子集。<br>（4）第9行：利用数据框访问的方式，抽取满足指定条件（质量等级等于优）行的数据。</p><h1>四、Matplotlib的综合应用：空气质量监测数据的图形化展示</h1><p><font color="#A0B0E0">Matplotlib是Python中最常用的绘图模块</font>，其主要特点如下：<br>（1）Matplotlib的Pyplot子模块与MATLAB非常相似，可以方便地绘制各种常见的统计图形，是用户进行探索式数据分析的重要工具。<br>（2）可以通过各种函数设置图形的图标题、线条样式、字符形状、颜色、轴属性以及字体属性等等。<br><strong>以下我们就用Matplotlib子模块Pyplot的强大功能基于空气质量监测数据进行画图。</strong></p><h3 id="4-1-AQI的时序变化特点">4.1 AQI的时序变化特点</h3><p><strong>以下代码利用Matplotlib的线图展示2014年至2019年每日AQI的时序变化特点（运行环境选取jupyter notebook）：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>%matplotlib inline<br>plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>]=[<span class="hljs-string">&#x27;SimHei&#x27;</span>]  <span class="hljs-comment">#解决中文显示乱码问题</span><br>plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>]=<span class="hljs-literal">False</span><br><br>data=pd.read_excel(<span class="hljs-string">&#x27;E:\python机器学习数据建模与分析\数据\北京市空气质量数据.xlsx&#x27;</span>)<br>data=data.replace(<span class="hljs-number">0</span>,np.NaN)   <span class="hljs-comment"># 将缺失值用0代替</span><br><br>plt.figure(figsize=(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>))<br>plt.plot(data[<span class="hljs-string">&#x27;AQI&#x27;</span>],color=<span class="hljs-string">&#x27;black&#x27;</span>,linestyle=<span class="hljs-string">&#x27;-&#x27;</span>,linewidth=<span class="hljs-number">0.5</span>)<br>plt.axhline(y=data[<span class="hljs-string">&#x27;AQI&#x27;</span>].mean(),color=<span class="hljs-string">&#x27;red&#x27;</span>, linestyle=<span class="hljs-string">&#x27;-&#x27;</span>,linewidth=<span class="hljs-number">0.5</span>,label=<span class="hljs-string">&#x27;AQI总平均值&#x27;</span>)<br>data[<span class="hljs-string">&#x27;年&#x27;</span>]=data[<span class="hljs-string">&#x27;日期&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x:x.year)<br>AQI_mean=data[<span class="hljs-string">&#x27;AQI&#x27;</span>].groupby(data[<span class="hljs-string">&#x27;年&#x27;</span>]).mean().values<br>year=[<span class="hljs-string">&#x27;2014年&#x27;</span>,<span class="hljs-string">&#x27;2015年&#x27;</span>,<span class="hljs-string">&#x27;2016年&#x27;</span>,<span class="hljs-string">&#x27;2017年&#x27;</span>,<span class="hljs-string">&#x27;2018年&#x27;</span>,<span class="hljs-string">&#x27;2019年&#x27;</span>]<br>col=[<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-string">&#x27;blue&#x27;</span>,<span class="hljs-string">&#x27;green&#x27;</span>,<span class="hljs-string">&#x27;yellow&#x27;</span>,<span class="hljs-string">&#x27;purple&#x27;</span>,<span class="hljs-string">&#x27;brown&#x27;</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>    plt.axhline(y=AQI_mean[i],color=col[i], linestyle=<span class="hljs-string">&#x27;--&#x27;</span>,linewidth=<span class="hljs-number">0.5</span>,label=year[i])<br>plt.title(<span class="hljs-string">&#x27;2014年至2019年AQI时间序列折线图&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;年份&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;AQI&#x27;</span>)<br>plt.xlim(xmax=<span class="hljs-built_in">len</span>(data), xmin=<span class="hljs-number">1</span>)<br>plt.ylim(ymax=data[<span class="hljs-string">&#x27;AQI&#x27;</span>].<span class="hljs-built_in">max</span>(),ymin=<span class="hljs-number">1</span>)<br>plt.yticks([data[<span class="hljs-string">&#x27;AQI&#x27;</span>].mean()],[<span class="hljs-string">&#x27;AQI平均值&#x27;</span>])<br>plt.xticks([<span class="hljs-number">1</span>,<span class="hljs-number">365</span>,<span class="hljs-number">365</span>*<span class="hljs-number">2</span>,<span class="hljs-number">365</span>*<span class="hljs-number">3</span>,<span class="hljs-number">365</span>*<span class="hljs-number">4</span>,<span class="hljs-number">365</span>*<span class="hljs-number">5</span>],[<span class="hljs-string">&#x27;2014&#x27;</span>,<span class="hljs-string">&#x27;2015&#x27;</span>,<span class="hljs-string">&#x27;2016&#x27;</span>,<span class="hljs-string">&#x27;2017&#x27;</span>,<span class="hljs-string">&#x27;2018&#x27;</span>,<span class="hljs-string">&#x27;2019&#x27;</span>])<br>plt.legend(loc=<span class="hljs-string">&#x27;best&#x27;</span>)<br>plt.text(x=<span class="hljs-built_in">list</span>(data[<span class="hljs-string">&#x27;AQI&#x27;</span>]).index(data[<span class="hljs-string">&#x27;AQI&#x27;</span>].<span class="hljs-built_in">max</span>()),y=data[<span class="hljs-string">&#x27;AQI&#x27;</span>].<span class="hljs-built_in">max</span>()-<span class="hljs-number">20</span>,s=<span class="hljs-string">&#x27;空气质量最差日&#x27;</span>,color=<span class="hljs-string">&#x27;red&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p>运行结果如下图所示：<br><img src="https://img-blog.csdnimg.cn/093a352e699a474e9007c936537634d2.png" alt="在这里插入图片描述"><br><strong>代码说明：</strong><br>（1）第3行：Matplotlib的Pyplot子模块，指定别名为plt。<br>（2）第5至7行：指定立即显示所绘图形，且通过参数设置解决图形中文显示乱码问题。<br>（3）第12行：利用函数plt.figure说明图形的一般特征，如这里宽为10高5。<br>（4）第13行：利用函数plt.plot绘制序列折线图（还可以绘制其他图）。同时，指定折线颜色、线形、线宽等。<br>（5）第14行：利用函数plt.axhline在参数y指定的位置上画一条平行于横坐标的直线，并给定直线图例文字。plt.axvline可参数x指定的位置上画一条平行于纵坐标的直线。<br>（6）第16至20行：首先，分组计算各年AQI的平均值；然后，通过for循环绘制多条平行于横坐标的直线，表征各年AQI平均值。<br>（7）第21至23行：利用title()、xlabel()、ylabel()指定图的标题，横纵坐标的坐标标签。<br>（8）第24，25行：利用xlim()、ylim()指定横纵坐标的取值范围。<br>（9）第26，27行：利用xticks()、yticks()在指定坐标刻度位置上给出刻度标签。<br>（10）第28行：利用legend()在指定位置（这里best表示最优位置）显示图例。<br>（11）第29行：利用text()在指定的行列位置上显示指定文字<br>（12）第30行：利用show()表示本次绘图结束。</p><h3 id="4-2-AQI的分布特征及相关性分析">4.2 AQI的分布特征及相关性分析</h3><p><strong>下面将利用Matplotlib，对空气质量监测数据做如下图形化展示：</strong></p><ul><li>利用线图展示2014年到2019年的年均AQI的变化特点。</li><li>利用直方图展示2014年到2019年AQI的整体分布特征。</li><li>利用散点图展示AQI和PM2.5的相关性。</li><li>利用饼图展示空气质量等级的分布特征。</li></ul><p><strong>具体代码如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> warnings<br>warnings.filterwarnings(action = <span class="hljs-string">&#x27;ignore&#x27;</span>)<br>plt.figure(figsize=(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>))<br>plt.subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br>plt.plot(AQI_mean,color=<span class="hljs-string">&#x27;black&#x27;</span>,linestyle=<span class="hljs-string">&#x27;-&#x27;</span>,linewidth=<span class="hljs-number">0.5</span>)<br>plt.title(<span class="hljs-string">&#x27;各年AQI均值折线图&#x27;</span>)<br>plt.xticks([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-string">&#x27;2014&#x27;</span>,<span class="hljs-string">&#x27;2015&#x27;</span>,<span class="hljs-string">&#x27;2016&#x27;</span>,<span class="hljs-string">&#x27;2017&#x27;</span>,<span class="hljs-string">&#x27;2018&#x27;</span>,<span class="hljs-string">&#x27;2019&#x27;</span>])<br>plt.subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>plt.hist(data[<span class="hljs-string">&#x27;AQI&#x27;</span>],bins=<span class="hljs-number">20</span>)<br>plt.title(<span class="hljs-string">&#x27;AQI直方图&#x27;</span>)<br>plt.subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>plt.scatter(data[<span class="hljs-string">&#x27;PM2.5&#x27;</span>],data[<span class="hljs-string">&#x27;AQI&#x27;</span>],s=<span class="hljs-number">0.5</span>,c=<span class="hljs-string">&#x27;green&#x27;</span>,marker=<span class="hljs-string">&#x27;.&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;PM2.5与AQI散点图&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;PM2.5&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;AQI&#x27;</span>)<br>plt.subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br>tmp=pd.value_counts(data[<span class="hljs-string">&#x27;质量等级&#x27;</span>],sort=<span class="hljs-literal">False</span>)  <span class="hljs-comment">#等同：tmp=data[&#x27;质量等级&#x27;].value_counts()</span><br>share=tmp/<span class="hljs-built_in">sum</span>(tmp)<br>labels=tmp.index<br>explode = [<span class="hljs-number">0</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0</span>]<br>plt.pie(share, explode = explode,labels = labels, autopct = <span class="hljs-string">&#x27;%3.1f%%&#x27;</span>,startangle = <span class="hljs-number">180</span>, shadow = <span class="hljs-literal">True</span>)<br>plt.title(<span class="hljs-string">&#x27;空气质量整体情况的饼图&#x27;</span>)<br></code></pre></td></tr></table></figure><p>结果如下图所示：<br><img src="https://img-blog.csdnimg.cn/b33dd28104cd4e6dbc52d16b07cc78db.png" alt="在这里插入图片描述"><br><strong>代码说明：</strong><br>（1）第1，2行：导入warnings模块，并指定忽略代码运行过程中的警告信息。<br>（2）第4行：subplot(2,2,1)表示将绘图区域分成2行2列4个单元，且下一副图将在第1个单元显示。<br>（3）第8行：subplot(2,2,2)表示将绘图区域分成2行2列4个单元，且下一副图将在第2个单元显示。<br>（4）第9行：利用hist()绘制AQI的直方图，图中包含20个柱形条，即将数据分成20组。<br>（5）第12行：利用scatter()绘制PM2.5和AQI的散点图。并指定点的大小（s），颜色（c）和形状（marker）。<br>（6）第21行：利用pie()绘制饼图。<br> <font color="000ff">绘制饼图之前，需事先计算饼图各个组成部分的占比，距离饼图中心位置的距离（那些组成部分需要拉出来突出显示）、标签等，以及第一个组成部分排放的起始位置等。</font></p><h3 id="4-3-优化空气质量状况的统计图形">4.3 优化空气质量状况的统计图形</h3><p>由<strong>于上图中四幅画出现了重叠现象，为此可采取以下方式对图形进行优化调整。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">fig,axes=plt.subplots(nrows=<span class="hljs-number">2</span>,ncols=<span class="hljs-number">2</span>,figsize=(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>))<br>axes[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>].plot(AQI_mean,color=<span class="hljs-string">&#x27;black&#x27;</span>,linestyle=<span class="hljs-string">&#x27;-&#x27;</span>,linewidth=<span class="hljs-number">0.5</span>)<br>axes[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>].set_title(<span class="hljs-string">&#x27;各年AQI均值折线图&#x27;</span>)<br>axes[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>].set_xticks([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br>axes[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>].set_xticklabels([<span class="hljs-string">&#x27;2014&#x27;</span>,<span class="hljs-string">&#x27;2015&#x27;</span>,<span class="hljs-string">&#x27;2016&#x27;</span>,<span class="hljs-string">&#x27;2017&#x27;</span>,<span class="hljs-string">&#x27;2018&#x27;</span>,<span class="hljs-string">&#x27;2019&#x27;</span>])<br>axes[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>].hist(data[<span class="hljs-string">&#x27;AQI&#x27;</span>],bins=<span class="hljs-number">20</span>)<br>axes[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>].set_title(<span class="hljs-string">&#x27;AQI直方图&#x27;</span>)<br>axes[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>].scatter(data[<span class="hljs-string">&#x27;PM2.5&#x27;</span>],data[<span class="hljs-string">&#x27;AQI&#x27;</span>],s=<span class="hljs-number">0.5</span>,c=<span class="hljs-string">&#x27;green&#x27;</span>,marker=<span class="hljs-string">&#x27;.&#x27;</span>)<br>axes[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>].set_title(<span class="hljs-string">&#x27;PM2.5与AQI散点图&#x27;</span>)<br>axes[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>].set_xlabel(<span class="hljs-string">&#x27;PM2.5&#x27;</span>)<br>axes[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>].set_ylabel(<span class="hljs-string">&#x27;AQI&#x27;</span>)<br>axes[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>].pie(share, explode = explode,labels = labels, autopct = <span class="hljs-string">&#x27;%3.1f%%&#x27;</span>,startangle = <span class="hljs-number">180</span>, shadow = <span class="hljs-literal">True</span>)<br>axes[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>].set_title(<span class="hljs-string">&#x27;空气质量整体情况的饼图&#x27;</span>)<br>fig.subplots_adjust(hspace=<span class="hljs-number">0.5</span>)<br>fig.subplots_adjust(wspace=<span class="hljs-number">0.5</span>)<br></code></pre></td></tr></table></figure><p>结果如下图所示：<br><img src="https://img-blog.csdnimg.cn/cc1522eb77454885b9a9d1e996d4aa93.png" alt="在这里插入图片描述"><br>由于饼图中的“无”比例分配不太清晰，所以单独重画一下：<br><img src="https://img-blog.csdnimg.cn/e472d9380c984315be5eee1c4edfd679.png#pic_center" alt="在这里插入图片描述"><br><strong>代码说明：</strong><br>（1）第1行：说明绘图区域的宽和高，并指定将绘图区域分成2行2列4个单元。结果将赋值给fig和axes对象。可通过fig对整个图的特征进行设置，axes对应各个单元格对象。<br>（2）通过图形单元索引的方式指定绘图单元。例如：axes[0,0]表示第1行第1列的单元格。<br>（3）单元格对象的图标题、坐标轴标签、坐标刻度等，需采用set_title()、set_xlabel()、set_ylabel()、set_xticks()、set_xticklabels()设置。<br>（3）第14，15行：利用subplots_adjust调整各图形单元行或列之间的距离。</p><h1>总结</h1><p>Python作为一款面向对象、跨平台并且开源的计算机语言，是机器学习实践的首选工具。入门Python机器学习应从了解并掌握Python的Numpy、Pandas、Matplotlib包开始。学习Python和完成机器学习实践的有效途径是：以特定的机器学习应用场景和数据作为出发点，沿着由浅入深的数据分析脉络，以逐个解决数据分析实际问题为目标，逐步展开对Python的学习和机器学习的实践。</p><blockquote><p>📢博客主页：<a href="https://blog.csdn.net/m0_63007797?spm=1011.2415.3001.5343">https://blog.csdn.net/m0_63007797?spm=1011.2415.3001.5343</a><br>📢欢迎点赞 👍 收藏 ⭐留言 📝 如有错误敬请指正！<br>📢本文由 心无旁骛~ 原创，首发于 CSDN博客🙉<br>📢停下休息的时候不要忘了别人还在奔跑，希望大家抓紧时间学习，全力奔赴更美好的生活✨</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
      <tag>Data analysis</tag>
      
      <tag>Data modeling</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习基础——k-近邻算法概述和简单实现</title>
    <link href="/2023/01/20/hello-world/"/>
    <url>/2023/01/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p><strong>本章内容</strong></p><ul><li>[ ] k-近邻分类算法</li><li>[ ] 从文本文件中解析数据</li></ul><h1>前言</h1><p>众所周知，电影可以按照题材分类，然而题材本身是如何定义的?由谁来判定某部电影属于哪个题材?也就是说同一题材的电影具有哪些公共特征?这些都是在进行电影分类时必须要考虑的问题。没有哪个电影人会说自己制作的电影和以前的某部电影类似,但我们确实知道每部电影在风格上的确有可能会和同题材的电影相近。那么动作片具有哪些共有特征，使得动作片之间非常类似,而与爱情片存在着明显的差别呢?动作片中也会存在接吻镜头,爱情片中也会存在打斗场景,我们不能单纯依靠是否存在打斗或者亲吻来判断影片的类型。但是爱情片中的亲吻镜头更多,动作片中的打斗场景也更频繁，基于此类场景在某部电影中出现的次数可以用来进行电影分类。本章第—节基于电影中出现的亲吻、打斗出现的次数，使用k-近邻算法构造程序，自动划分电影的题材类型。我们首先使用电影分类讲解k-近邻算法的基本概念，然后学习如何在其他系统上使用k-近邻算法。<br>本章介绍第一个机器学习算法:k-近邻算法，它非常有效而且易于掌握。首先，我们将探讨k-近邻算法的基本理论，以及如何使用距离测量的方法分类物品;其次我们将使用Python从文本文件中导人并解析数据。</p><h1>1 k-近邻算法概述</h1><p>简单地说，k-近邻算法采用测量不同特征值之间的距离方法进行分类。</p><p><strong>优点：精度高、对异常值不敏感、无数据输入假定。<br>缺点：计算复杂度高、空间复杂度高。<br>适用数据范围：数值型和标称型。</strong><br>k-近邻算法（kNN）的==工作原理==是：存在一个样本数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一条数据与所属分类的对应关系。输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签。一般来说，我们只选择样本数据集中前k个最相似的数据，这就是k-近邻算法中k的出处，通常k是不大于20的整数。最后，选择k个最相似数据中出现次数最多的分类标签，作为新数据的分类。<br>现在我们回到前面电影分类的例子，使用k-近邻算法分类爱情片和动作片。有人曾经统计过很多电影的打斗镜头和接吻镜头，图2-1显示了6部电影的打斗和接吻镜头数。假如有一部未看过的电影，如何确定它是爱情片还是动作片呢?我们可以使用kNN来解决这个问题。<br><img src="https://img-blog.csdnimg.cn/e70a581d7bd14f348e0615ebd5a8c847.png" alt="在这里插入图片描述"><br>首先我们需要知道这个未知电影存在多少个打斗镜头和接吻镜头，图2-1中问号位置是该未知电影出现的镜头数图形化展示，具体数字参见表2-1。<br><img src="https://img-blog.csdnimg.cn/0771ba159826491385713bd199284313.png" alt="在这里插入图片描述"><br>即使不知道未知电影属于哪种类型，我们也可以通过某种方法计算出来。首先计算未知电影与样本集中其他电影的距离，如表2-2所示。此处暂时不要关心如何计算得到这些距离值，使用Python实现电影分类应用时，会提供具体的计算方法。<br><img src="https://img-blog.csdnimg.cn/adaf69e708064c029cdd8cbe94563ea2.png" alt="在这里插入图片描述"><br>现在我们得到了样本集中所有电影与未知电影的距离，按照距离递增排序，可以找到k个距离最近的电影。假定k=3，则三个最靠近的电影依次是He 's Not Really into Dudes、Beautiful Woman和California Man。k-近邻算法按照距离最近的三部电影的类型，决定未知电影的类型，而这三部电影全是爱情片，因此我们判定未知电影是爱情片。<br>本章主要讲解如何在实际环境中应用k-近邻算法，同时涉及如何使用Python工具和相关的机器学习术语。按照开发机器学习应用的通用步骤，我们使用Python语言开发k-近邻算法的简单应用，以检验算法使用的正确性。</p><p><strong>k-近邻算法的一半流程：</strong><br>（1）收集数据：可以使用任何方法。<br>（2）准备数据：距离计算所需要的数值，最好是结构化的数据格式。<br>（3）分析数据：可以使用任何方法。<br>（4）训练算法：此步骤不适用与k-近邻算法。<br>（5）测试算法：计算错误率。<br>（6）使用算法：首先需要输入样本数据和结构化的输出结果，然后运行k-近邻算法判定输入数据分别属于哪个分类，最后应用对计算出的分类执行后续的处理。</p><h3 id="1-1-准备-使用python导入数据">1.1 准备: 使用python导入数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> operator<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">createDataSet</span>():<br>    group = np.array([[<span class="hljs-number">1.0</span>, <span class="hljs-number">1.1</span>], [<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>]])<br>    labels = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>]<br>    <span class="hljs-keyword">return</span> group, labels<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们导入了两个模块，第一个是科学计算包Numpy，第二个是运算符模块。k-近邻算法执行排序操作的时候会用到operator运算符模块提供的函数，后面我们将进一步介绍。<br>打开python编译器，本文用pycharm进行编译示范。用group和labels变量接收createDataset()函数的两个返回值并输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">group, labels = createDataSet()<br><span class="hljs-built_in">print</span>(group)<br><span class="hljs-built_in">print</span>(labels)<br><span class="hljs-comment"># 输出如下:</span><br>[[<span class="hljs-number">1.</span>  <span class="hljs-number">1.1</span>]<br> [<span class="hljs-number">1.</span>  <span class="hljs-number">1.</span> ]<br> [<span class="hljs-number">0.</span>  <span class="hljs-number">0.</span> ]<br> [<span class="hljs-number">0.</span>  <span class="hljs-number">0.1</span>]]<br>[<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>]<br></code></pre></td></tr></table></figure><p>group输出的结果里面有4组数据，每组数据有两个我们已知的属性或者特征值。上面的group矩阵每行包含一个不同的数据，我们可以把它想象为某个日志文件中不同的测量点或者入口。由于人脑的限制，我们通常只能可视化处理三维以下的事务。因此为了简单地实现数据可视化，对于每个数据点我们通常只使用两个特征。<br>向量label包含了每个数据点的标签信息，label包含的元素个数等于group矩阵行数。这里我们将数据点(1，1.1)定义为类A，数据点(0,0.1)定义为类B。为了说明方便，例子中的数值是任意选择的，并没有给出轴标签，图2-2是带有类标签信息的四个数据点。<br><img src="https://img-blog.csdnimg.cn/8b888bad2c254defa1544bcde6ce2159.png#pic_center" alt="在这里插入图片描述"><br>现在我们已经知道Python如何解析数据，如何加载数据，以及kNN算法的工作原理，接下来我们将使用这些方法完成分类任务。</p><h3 id="1-2-从文本文件中解析数据">1.2 从文本文件中解析数据</h3><p>这里首先给出k-近邻算法的伪代码和实际的python代码，然后详细地解释每行代码的含义。其伪代码如下：<br>对未知类别属性的数据集中的每个点依次执行以下操作：<br>（1）计算已知类别数据集中的点与当前未知类别数据集中点之间的距离。<br>（2）按照距离递增次序排序。<br>（3）选取与当前点距离最小的k个点。<br>（4）确定前k个点所在类别的出现频率，按从小到大的排列返回索引列表。<br>（5）返回前k个点出现频率最高的类别作为当前点的预测分类。<br><strong>python函数classify0（）如程序清单2-1所示</strong><br><img src="https://img-blog.csdnimg.cn/4a2d78298e67447e9efb90f7f40129de.png" alt="在这里插入图片描述"><br>classify0()函数有4个输人参数:用于分类的输人向量是inX,输入的训练样本集为dataSet,标签向量为labels，最后的参数k表示用于选择最近邻居的数目，其中标签向量的元素数目和矩阵dataset的行数相同。<br>程序清单2-1使用欧氏距离公式，计算两个向量点xA和xB之间的距离①:</p><p>$$<br>d= \sqrt{（xA_0-xB_0）^2+(xA_1-xB_1)^2}<br>$$<br>例如，点(0, 0)与(1,2)之间的距离计算为:<br>$$<br>\sqrt{(1-0)^2+(2-0)^2}<br>$$<br>如果数据集存在4个特征值，则点(1,0,0,1)与(7,6,9,4)之间的距离计算为:<br>$$<br>\sqrt{(7-1)^2+(6-0)^2+（9-1)^2+(4-1)^2}<br>$$<br>计算完所有点之间的距离后，可以对数据按照从小到大的次序排序。然后，确定前k个距离最小元素所在的主要分类2，输入k总是正整数;最后，将classCount字典分解为元组列表，然后使用程序第二行导人运算符模块的itemgetter方法,按照第二个元素的次序对元组进行排序③。·此处的排序为逆序，即按照从最大到最小次序排序，最后返回发生频率最高的元素标签。<br><strong>完整代码如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> operator<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">createDataSet</span>():<br>    group = np.array([[<span class="hljs-number">1.0</span>, <span class="hljs-number">1.1</span>], [<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>]])<br>    labels = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>]<br>    <span class="hljs-keyword">return</span> group, labels<br>group, labels = createDataSet()<br><span class="hljs-built_in">print</span>(group)<br><span class="hljs-built_in">print</span>(labels)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">classify0</span>(<span class="hljs-params">inX, dataSet, labels, k</span>):<br>    dataSetSize = dataSet.shape[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 距离计算</span><br>    diffMat = np.tile(inX, (dataSetSize, <span class="hljs-number">1</span>)) - dataSet<br>    sqDiffMat = diffMat ** <span class="hljs-number">2</span><br>    <span class="hljs-built_in">print</span>(sqDiffMat)<br>    sqDistances = sqDiffMat.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 沿着1维降维，即把列全部压缩，只剩下一列，保留所有行</span><br>    <span class="hljs-built_in">print</span>(sqDistances)<br>    distances = sqDistances**<span class="hljs-number">0.5</span><br>    <span class="hljs-built_in">print</span>(distances)<br>    sortedDistIndicies = distances.argsort()     <span class="hljs-comment"># 返回数组值从小到大的索引值</span><br>    <span class="hljs-built_in">print</span>(sortedDistIndicies)<br>    classCount = &#123;&#125;<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>        voteIlabel = labels[sortedDistIndicies[i]]<br>        <span class="hljs-built_in">print</span>(sortedDistIndicies[i])<br>        <span class="hljs-built_in">print</span>(voteIlabel)<br>        classCount[voteIlabel] = classCount.get(voteIlabel, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(classCount)<br>    <span class="hljs-built_in">print</span>(classCount.items())<br>    sortedClassCount = <span class="hljs-built_in">sorted</span>(classCount.items(), key=operator.itemgetter(<span class="hljs-number">1</span>), reverse=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># python3.x以上的版本中，iteritems()方法已经被删除，items()函数替代了它的功能，可以for循环遍历</span><br>    <span class="hljs-built_in">print</span>(sortedClassCount)           <span class="hljs-comment"># key = operator.itemgetter(1),指的是按照dict_items([(&#x27;B&#x27;, 2), (&#x27;A&#x27;, 1)])中后一个元素进行排序，即2和1，如果是0的话就是按照B和A排序</span><br>    <span class="hljs-keyword">return</span> sortedClassCount[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]     <span class="hljs-comment"># reverse=True指的是降序，即按照从大到小，返回[0][0]获取最大标签出现次数的标签，也就是B</span><br><br><br><span class="hljs-built_in">print</span>(classify0([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], group, labels, <span class="hljs-number">3</span>))<br><span class="hljs-comment"># 输出结果</span><br><span class="hljs-comment"># group矩阵</span><br>[[<span class="hljs-number">1.</span>  <span class="hljs-number">1.1</span>]<br> [<span class="hljs-number">1.</span>  <span class="hljs-number">1.</span> ]<br> [<span class="hljs-number">0.</span>  <span class="hljs-number">0.</span> ]<br> [<span class="hljs-number">0.</span>  <span class="hljs-number">0.1</span>]]<br> <span class="hljs-comment"># labels标签列表</span><br>[<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>]<br>[[<span class="hljs-number">1.</span>   <span class="hljs-number">1.21</span>]<br> [<span class="hljs-number">1.</span>   <span class="hljs-number">1.</span>  ]<br> [<span class="hljs-number">0.</span>   <span class="hljs-number">0.</span>  ]<br> [<span class="hljs-number">0.</span>   <span class="hljs-number">0.01</span>]]<br>[<span class="hljs-number">2.21</span> <span class="hljs-number">2.</span>   <span class="hljs-number">0.</span>   <span class="hljs-number">0.01</span>]<br>[<span class="hljs-number">1.48660687</span> <span class="hljs-number">1.41421356</span> <span class="hljs-number">0.</span>         <span class="hljs-number">0.1</span>       ]<br><span class="hljs-comment"># 从小到大的索引</span><br>[<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span>]<br><span class="hljs-number">2</span><br>B<br><span class="hljs-number">3</span><br>B<br><span class="hljs-number">1</span><br>A<br><span class="hljs-comment"># classCount的内容</span><br>&#123;<span class="hljs-string">&#x27;B&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;A&#x27;</span>: <span class="hljs-number">1</span>&#125;<br><span class="hljs-comment"># 使用items返回字典内容为列表</span><br>dict_items([(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">1</span>)])<br><span class="hljs-comment"># 使用itemgetter对第二个元素也就是数字2和1进行从大到小排序后的结果。</span><br>[(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">1</span>)]<br><span class="hljs-comment"># 输出最终结果，也就是标签次数出现最多的结果B</span><br>B<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
      <tag>Arithmetic</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
